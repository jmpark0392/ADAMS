<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>계정과목관리</title>
    <link rel="stylesheet" href="/js/slickgrid/dist/styles/css/slick.grid.css" type="text/css"/>
    <link rel="stylesheet" href="/js/slickgrid/dist/styles/css/slick-alpine-theme.css" type="text/css"/>
    
    <style>
    .slick-header-columns {
        --alpine-header-name-flex-grow: 1;
    }
    .slick-cell.copied {
      background: blue;
      background: rgba(0, 0, 255, 0.2);
      transition: 0.5s background;
    }
    .slick-container {
      --alpine-header-column-height: 20px;
      --alpine-header-font-weight: 500;
      --alpine-cell-border-width: 0 1px 1px 0;
      --alpine-cell-border-color: #d4d4d4;
    }
    #divMyGrid, #divMyGridB {
        background: white;
        outline: 0;
        border: 1px solid gray;
    }
    .modal {
      z-index: 10000;
      display: inline-block;
      border: 1px solid black;
      margin: 8px;
      background: #fbfbfb;
      box-shadow: 0px 0px 15px black;
      position: absolute;
      top: 10px;
      left: 150px;
      width: 300px;
    }
    .modal h5 {
      font-size: 18px;
      margin: 0;
      line-height: 20px;
    }
    .modal-body {
      padding: 8px;
    }
    .modal-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 8px;
      height: 25px;
      border-bottom: 1px solid #c9c9c9;
    }
    .modal-footer {
      margin-top: 5px;
      border-top: 1px solid #c9c9c9;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      padding: 8px;
    }
    .modal-footer button {
      margin-right: 5px;
    }
    .item-details-label {
      margin-left: 10px;
      margin-top: 15px;
      display: block;
      font-weight: bold;
    }
    .item-details-editor-container {
      border: 1px solid silver;
      background: white;
      display: block;
      margin: 4px 10px;
      margin-top: 4px;
      padding: 0;
      padding-left: 4px;
      padding-right: 0px;
      line-height: 20px;
    }
    .item-details-editor-container textarea {
      height: inherit;
    }
    .invalid {
      color: red;
    }
    .item-details-editor-container.invalid {
      border: 1px solid red;    
    }
    .item-details-validation {
      color: red;
      font-style: italic;
      margin-left: 12px;
    }
		header {
	        height: 60px;
	        border : solid 0.5px #000000;
	        background-color: #BFD8F2;
			font-size:30px;
		}
		main {
	        border: solid 0.5px #000000;
	        width: 1200px;
	        height: 700px;
		}
	    aside {
	        width: 120px;
	        height: 900px;
	        float: left;
	        border: solid 0.5px #000000;
	        background-color: #BFD8F2;
	
	    }
	    footer{
	        height: 30px;
	        margin: 2px;
	        border: solid 0.5px #000000;
	        background-color: #BFD8F2;
	    }
    </style>
</head>
<!---------- header,left (시작) -------------->
    <header align="center">
	<b>File Management System(Extract,Load,View)</b>
	<img height="60" src="/images/img_charater.png" align="right"></header>
	<aside>
	  &nbsp;파일관리<br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/WRK/FIL/WRKFIL001M0.html" target="main">파일관리</a><br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/WRK/FIL/WRKFIL002M0.html" target="main">칼럼관리</a><br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/WRK/FIL/WRKFIL003M0.html" target="main">업로드  </a><br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/WRK/FIL/WRKFIL004M0.html" target="main">적재이력</a><br>
	  &nbsp;&nbsp;&nbsp;검증관리(X)                                <br>
	  &nbsp;&nbsp;&nbsp;검증결과(X)                                <br>
	  &nbsp;&nbsp;&nbsp;파일목록(X)                                <br>
	  &nbsp;시스템관리<br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/MST/SYS/MSTSYS001M0.html" target="main">사용자관리</a><br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/MST/SYS/MSTSYS002M0.html" target="main">코드관리</a><br>
	  &nbsp;&nbsp;&nbsp;게시판(X)<br>
	  &nbsp;배치관리<br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/WRK/BAT/WRKBAT001M0.html" target="main">배치관리</a><br>
	  &nbsp;&nbsp;&nbsp;배치실행(X)<br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/WRK/BAT/WRKBAT003M0.html" target="main">배치결과</a><br>
	  &nbsp;배치관리<br>
	  &nbsp;&nbsp;&nbsp;데이터현황(X)<br>
	  &nbsp;&nbsp;&nbsp;데이터상세(X)<br>
	  &nbsp;ETL<br>
	  &nbsp;&nbsp;&nbsp;DBtoDB(X)<br>
	  &nbsp;&nbsp;&nbsp;DBtoFile(X)<br>
	  &nbsp;&nbsp;&nbsp;FileToDb(X)<br>
	  &nbsp;계정관리<br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/BIZ/JNL/BIZJNL001M0.html" target="main">계정과목관리</a><br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/BIZ/JNL/BIZJNL002M0.html" target="main">분개룰관리</a><br>
	  &nbsp;&nbsp;&nbsp;<a href ="/views/BIZ/JNL/BIZJNL003M0.html" target="main">분개내역</a><br>
	</aside>
<!---------- header,left (종료) -------------->
<body>
    <form name="form" method="post" action="/BIZFST001M0SelectList" onsubmit="return false;">
        * 조회조건<br/>
        검색 : <input type="text"   id="inpSearchTxt" name="inpSearchTxt" value=""><br/>
             <input type="button" id="inpSend"      value="send"  onclick="main()"/>
        <p>&nbsp;</p>
    </form>
    <button 
        form="new-form"
        onclick="renewOptions(true);openDetails('create');{(ev) => {if (ev.detail === 0) {ev.preventDefault();}}}" data-test="create-button" onsubmit="return false;"
    >
     신규
    </button>
    <button 
        form="new-form"
        onclick="renewOptions(true);openDetails('edit');{(ev) => {if (ev.detail === 0) {ev.preventDefault();}}}" data-test="edit-button" onsubmit="return false;"
    >
     수정
    </button>
    <button id="downloadExcel">다운로드(엑셀)</button>
    <table align="center">
        <div id="divMyGrid" style="width:1200px;height:500px;"></div>
    </table>
    <script src="../../../js/jquery-3.7.1.min.js"></script>
    <script src="../../../js/jquery-ui.min.js"></script>
    <script src="/js/slickgrid/lib/jquery.event.drag-2.3.0.js"></script>
    
    <script src="/js/slickgrid/dist/browser/slick.core.js"></script>
    <script src="/js/slickgrid/dist/browser/slick.interactions.js"></script>
    <script src="/js/slickgrid/dist/browser/slick.grid.js"></script>
    <script src="/js/slickgrid/dist/browser/slick.dataview.js"></script>
    
    <script src="/js/slickgrid/dist/browser/plugins/slick.autotooltips.js"></script>
    <script src="/js/slickgrid/dist/browser/plugins/slick.cellrangedecorator.js"></script>
    <script src="/js/slickgrid/dist/browser/plugins/slick.cellrangeselector.js"></script>
    <script src="/js/slickgrid/dist/browser/plugins/slick.cellexternalcopymanager.js"></script>
    <script src="/js/slickgrid/dist/browser/plugins/slick.cellselectionmodel.js"></script>
    <script src="/js/slickgrid/dist/browser/plugins/slick.checkboxselectcolumn.js"></script>
    <script src="/js/slickgrid/dist/browser/plugins/slick.rowselectionmodel.js"></script>
    <script src="/js/slickgrid/dist/browser/slick.editors.js"></script>
    <script src="/js/slickgrid/dist/browser/slick.formatters.js"></script>
    <script src="/js/slickgrid/dist/browser/slick.compositeeditor.js"></script>
    <script src="/js/slickgrid/dist/browser/controls/slick.pager.js"></script>
    <script src="/js/xlsx.full.min.js"></script>
    <script src="/js/utils.js"></script>
    <script>
        function checkData(data){
            return parentCheckData(data, check_cols);
        }
        
        function getFile(input){
            return parentGetFile(input, '/BIZFST001M0SelectList');
        }
        
    </script>
    <script>
        $(document).ready(function() {
            console.log("Document is ready.");
            //화면 접속시 바로 조회
            main();
            //send버튼 누르면, 조건적용하여 검색
            $("#send").click(main);
            //엔터키누르면, 조건적용하여 검색
            $("input").on("keyup", function(key) {
                if (key.keyCode == 13) {
                    main();
                }
            });
        });
        
        var grid;
        var dataView;
        var data;
        var unqId = "rowNumber";
        var xcpt_cols = [unqId, "regUsrid", "regDt"];
        var check_cols = [unqId, "atitNm"];
        var columns = [
            {id: "atitCd", name: "account title", field: "atitCd", sortable: true, editor: Slick.Editors.Text, validator: createValidator},
            {id: "atitNm", name: "account name", field: "atitNm", sortable: true, editor: Slick.Editors.Text, validator: createValidator},
            {id: "basAmt", name: "basis of term", field: "basAmt", sortable: true, editor: Slick.Editors.Text, validator: createValidator},
            {id: "drAmt", name: "dr", field: "drAmt", sortable: true, editor: Slick.Editors.Text, validator: createValidator},
            {id: "crAmt", name: "cr", field: "crAmt", sortable: true, editor: Slick.Editors.Text, validator: createValidator},
            {id: "entmAmt", name: "end of term", field: "entmAmt", sortable: true, editor: Slick.Editors.Text, validator: createValidator},
            {id: "regUsrid", name: "registrant", field: "regUsrid", sortable: true, editor: Slick.Editors.Text},
            {id: "regDt", name: "registration date", field: "regDt", sortable: true, editor: Slick.Editors.Text}
        ];
        
        var options = {
            enableCellNavigation: true,
            enableColumnReorder: false,
            forceFitColumns: true,
            multiColumnSort: true,
            numberedMultiColumnSort: true,
            tristateMultiColumnSort: true,
            sortColNumberInSeparateSpan: true,
            enableAutoSizeColumns: true,
            editable: false,   // grid도 편집가능.. grid 편집 기능 제거 필요..
            enableAddRow: true,
            asyncEditorLoading: false,
            autoEdit: false,
            autoEditNewRow: false
        };
        
        var newRowIds = 0;
    
        var pluginOptions = {
            clipboardCommandHandler: function(editCommand){ undoRedoBuffer.queueAndExecuteCommand.call(undoRedoBuffer,editCommand); },
            readOnlyMode : false,
            includeHeaderWhenCopying : false,
            newRowCreator: function(count) {
                for (var i = 0; i < count; i++) {
                    var item = {
                        id: "newRow_" + newRowIds++
                    }
                grid.getData().addItem(item);
                }
            }
        };
        
        function main(){
            // 그리드 초기화 및 데이터 로드
            console.log("Initializing SlickGrid...");
            data = getFile(input=JSON.stringify({ searchTxt: $("#inpSearchTxt").val() }))
            
            dataView = new Slick.Data.DataView();
            grid = new Slick.Grid("#divMyGrid", dataView, columns, options);
            
            // Make the grid respond to DataView change events.
            dataView.onRowCountChanged.subscribe(function (e, args) {
              grid.updateRowCount();
              grid.render();
            });
            
            dataView.onRowsChanged.subscribe(function (e, args) {
              grid.invalidate();
              grid.render();
            });
            
            // setItems의 두번째 argument를 통해 unique id에 해당하는 컬럼 지정가능
            dataView.setItems(data, unqId);
            
            // when "onBeforeSort" returns false, the "onSort" won't execute (for example a backend server error while calling backend query to sort)
            grid.onBeforeSort.subscribe(function (e, args) {
              return true;
            });
            
            // 정렬
            grid.onSort.subscribe(function (e, args) {
                
                var cols = args.sortCols;
        
                data.sort(function (dataRow1, dataRow2) {
                    for (var i = 0, l = cols.length; i < l; i++) {
                        var field = cols[i].sortCol.field;
                        var sign = cols[i].sortAsc ? 1 : -1;
                        var value1 = dataRow1[field], value2 = dataRow2[field];
                        var result = (value1 == value2 ? 0 : (value1 > value2 ? 1 : -1)) * sign;
                        if (result != 0) {
                            return result;
                        }
                    }
                    return 0;
                });
                
                grid.render();
            });
            
            grid.setSelectionModel(new Slick.CellSelectionModel());
            grid.registerPlugin(new Slick.AutoTooltips());
            
            // set keyboard focus on the grid
            grid.getCanvasNode().focus();
            grid.registerPlugin(new Slick.CellExternalCopyManager(pluginOptions));
            
            grid.onAddNewRow.subscribe(function (e, args) {
              var newItem = args.item;
              var column = args.column;
              dataView.beginUpdate();
              dataView.setItems(data);
              dataView.endUpdate();
              grid.updateRowCount();
              grid.render();
            });
            
            grid.onBeforeEditCell.subscribe(function (e, args) {
              console.log("onBeforeEditCell");
            })
            
            grid.onCellChange.subscribe(function (e, args) {
              dataView.beginUpdate();
              dataView.setItems(data);
              dataView.endUpdate();
              grid.updateRowCount();
              grid.render();
            });
            
            grid.onValidationError.subscribe(function (e, args) {
              // handle validation errors originating from the CompositeEditor
              if (args.validationResults) {
                let errorMsg = args.validationResults.msg || '';
                if (args.editor && (args.editor instanceof Slick.CompositeEditor)) {
                  if (args.validationResults.errors) {
                    errorMsg += '\n';
                    args.validationResults.errors.forEach(function (error, errorIndex) {
                      const columnName = error.editor.args.column.id;
                      errorMsg += `${columnName.toUpperCase()}: ${error.msg}`;
                    });
                  }
                  console.log(errorMsg);
                }
              } else {
                alert(errorMessages);
              }
            });
            
            grid.setActiveCell(0, 0);
            console.log("SlickGrid initialized.");
        };
        
        // Download Excel functionality
        document.getElementById('downloadExcel').addEventListener('click', function() {
            const currDate = getCurrentDateTime();
            const fileName = 'BIZJNL001_FM_' + currDate; // 원하는 파일 이름으로 변경 가능
            const sheetName = '계정과목관리'; // 시트 이름
            const gridColumns = columns; // SlickGrid의 컬럼 배열
            const gridData = dataView.getItems(); // SlickGrid의 데이터 배열
            exportToExcel(fileName, sheetName, gridColumns, gridData);
        });
        
        // 신규버튼 누르면 동작하는 함수
        function openDetails(modalType) {
            grid.render();
            
            let originalData = null; // 수정 직전의 데이터를 저장할 변수
            
            if (grid.getEditorLock().isActive() && !grid.getEditorLock().commitCurrentEdit()) {
              return;
            }
            
            //신규버튼을 누르면 가장 아래 셀을 선택 후 신규만 입력하도록 ActiveCell을 설정
            if (modalType === "create"){
                this.grid.setActiveCell(grid.getDataLength(), 0);
            }
            
            var activeCell = this.grid.getActiveCell();
            var activeRow = activeCell && activeCell.row || 0;
            
            if (!options.enableCellNavigation) {
              throw new Error('Composite Editor requires the flag "enableCellNavigation" to be set to True in your Grid Options.');
            } else if (!activeCell && modalType === "edit") {
              throw new Error('No records selected for edit operation');
            } else {
              var dataContext = grid.getDataItem(activeRow);
              var isWithMassUpdate = (modalType === "mass-update" || modalType === "mass-selection");
              lastActiveRowNumber = activeRow;
              
              // 수정 직전의 데이터 저장
              if (modalType === "edit") {
                originalData = JSON.parse(JSON.stringify(dataContext));
                console.log("originalData: ", originalData);
              }
              
              // focus on a first cell with an Editor (unless current cell already has an Editor then do nothing)
              // also when it's a "Create" modal, we'll scroll to the end of the grid
              var rowIndex = modalType === "create" ? data.length : activeRow;
              focusOnFirstCellWithEditor(columns, rowIndex, isWithMassUpdate);
        
              if (modalType === "edit" && !dataContext) {
                alert("Current row is not editable");
                return;
              } else if (modalType === "mass-selection") {
                var selectedRowsIndexes = grid.getSelectedRows();
                if (selectedRowsIndexes.length < 1) {
                  alert("You must select some rows before trying to apply new value(s)");
                  return;
                }
              }
          
              var modalColumns;
              
              //업데이트 대상제외 컬럼 필터링
              var selColumns = []
              for (let index = 0; index < columns.length; index++) {
                 const element = columns[index];
                 if (xcpt_cols.includes(element['id'])) {
                     continue;
                     } 
                 else {
                     selColumns.push(element);
                     }
                 }
        
              if (isWithMassUpdate) {
                // when using Mass Update, we only care about the columns that have the "massUpdate: true", we disregard anything else
                modalColumns = selColumns.filter(function (col) { return col && col.massUpdate && col.editor });
              } else {
                modalColumns = selColumns.filter(function (col) { return col && col.editor });
              }
        
              let headerTitle = "";
              switch (modalType) {
                case "create":
                  headerTitle = "계정과목관리 추가";
                  break;
                case "edit":
                  headerTitle = `계정과목관리 수정`;
                  break;
                case "mass-update":
                  headerTitle = "Mass Update (all rows)";
                  break;
                case "mass-selection":
                  headerTitle = "Update on Current Selection";
                  break;
              }
        
              const modalElm = document.createElement('div');
              modalElm.className = 'modal slick-composite-editor-modal';
        
              const modalHeaderElm = document.createElement('div');
              modalHeaderElm.className = 'modal-header';
              modalHeaderElm.innerHTML = `<h5>${headerTitle}</h5>
                <button type="button" class="close" data-action="close" aria-label="Close">
                  <span aria-hidden="true">×</span>
                </button>`;
              modalElm.appendChild(modalHeaderElm);
          
              const modalBodyElm = document.createElement('div');
              modalBodyElm.className = 'modal-body';
          
              for (const column of modalColumns) {
                if (column.editor) {
                  const detailLabelElm = document.createElement('div');
                  detailLabelElm.className = `item-details-label editor-${column.id}`;
                  detailLabelElm.textContent = column.name;
          
                  const detailContainerElm = document.createElement('div');
                  detailContainerElm.className = 'item-details-editor-container';
                  detailContainerElm.dataset.editorid=column.id;
                  detailContainerElm.style.height = column.id === 'desc' ? 'inherit' : '20px';
          
                  const detailValidationElm = document.createElement('div');
                  detailValidationElm.className = `item-details-validation editor-${column.id}`;
          
                  modalBodyElm.appendChild(detailLabelElm);
                  modalBodyElm.appendChild(detailContainerElm);
                  modalBodyElm.appendChild(detailValidationElm);
                }
              }
              
              modalElm.appendChild(modalBodyElm);
        
              let saveActionType = (modalType === "create" || modalType === "edit") ? "save" : modalType;
              let saveButtonText = (modalType === "create" || modalType === "edit")
                ? "Save"
                : (modalType === "mass-update")
                  ? "Apply Mass Update"
                  : "Apply Update to Current Selection";
              
              const modalFooterElm = document.createElement('div');
              modalFooterElm.className = 'modal-footer';
          
              const saveBtnElm = document.createElement('button');
              saveBtnElm.className = 'slick-btn slick-btn-primary';
              saveBtnElm.dataset.action = saveActionType;
              saveBtnElm.textContent = saveButtonText;
              
              // Delete 버튼 추가
              const deleteBtnElm = document.createElement('button');
              deleteBtnElm.className = 'slick-btn slick-btn-default';
              deleteBtnElm.dataset.action = 'delete';
              deleteBtnElm.textContent = 'Delete';
              deleteBtnElm.type = 'submit'; // button type 설정
          
              const cancelBtnElm = document.createElement('button');
              cancelBtnElm.className = 'slick-btn slick-btn-default';
              cancelBtnElm.dataset.action = 'cancel';
              cancelBtnElm.textContent = 'Cancel';
              
              modalFooterElm.appendChild(saveBtnElm);
              if(modalType === "edit"){
                modalFooterElm.appendChild(deleteBtnElm);
              }
              modalFooterElm.appendChild(cancelBtnElm);
              modalElm.appendChild(modalFooterElm);
              
              document.body.appendChild(modalElm);
              
              modalElm.addEventListener('focusout', function (e) {
                validateCompositeEditors(e.target);
              });
              
              modalElm.addEventListener('keydown', (function (e) {
                if (e.which == Slick.keyCode.ESCAPE) {
                  grid.getEditController().cancelCurrentEdit();
                  grid.setActiveRow(lastActiveRowNumber, suppressScrollIntoView=true);
                  e.stopPropagation();
                  e.preventDefault();
                } else if (e.which === Slick.keyCode.TAB) {
                  validateCompositeEditors(e.target);
                }
              }));
              
              //modal을 마우스로 드래그가능하도록 설정
              $('.modal').draggable();
              
              grid.onClick.subscribe(function(e, args) {
                  renewOptions(false);
              });
              
              if (modalElm.querySelector("[data-action=save]")) {
                modalElm.querySelector("[data-action=save]").addEventListener('click', function (e, args) {
                  const formData = {};
                  modalColumns.forEach(column => {
                    const container = modalBodyElm.querySelector(`[data-editorid="${column.id}"]`);
                    if (container) {
                      const input = container.querySelector('input, select');
                      if (input) {
                        formData[column.id] = removeSpaces(input.value); // 띄어쓰기 삭제로직추가
                      }
                    }
                  });
        
                  if(modalType === "create"){
                    //데이터 추가
                    //DB Insert 요청
                    if(checkData(formData)){
                        insertFile(formData);
                        //formData[unqId] = grid.getDataLength() + 1;
                        dataView.insertItem(unqId, formData);
                    } else {
                        alert('No new data to save');
                    }
                  } else if(modalType === "edit"){
                      //업데이트
                      var isChanged = false;
                      
                      //기존데이터 확인
                      const orgData = originalData;
                      
                      // 변경된 데이터가 있는지 확인
                      for (var key in formData) {
                          if (formData[key] !== orgData[key]) {
                              isChanged = true;
                              break;
                          }
                      }
                      
                      // 변경된 데이터가 있는 경우에만 업데이트 요청
                      if (checkData(formData) && isChanged) {
                          //DB Update 요청
                          const _formData = {...formData}
                          _formData[unqId] = orgData[unqId]
                          updateFile(_formData);
                      } else if (!checkData(formData) && isChanged) {
                          alert("Please check data.")
                      } else if (checkData(formData) && !isChanged){
                          alert("No changes detected, update request not sent.");
                      } else {
                          alert("No changes detected and Need to check data.");
                      }
                  }
                  grid.getEditController().commitCurrentEdit();
                  grid.render();
                  renewOptions(false);
                });
              }
              
              if (modalElm.querySelector("[data-action=delete]")) {
                modalElm.querySelector("[data-action=delete]").addEventListener('click', function (e, args) {
                  const formData = {};
                  modalColumns.forEach(column => {
                    const container = modalBodyElm.querySelector(`[data-editorid="${column.id}"]`);
                    if (container) {
                      const input = container.querySelector('input, select');
                      if (input && column.id === unqId) {
                        formData[column.id] = removeSpaces(input.value); // 띄어쓰기 삭제로직추가
                      }
                    }
                  });
                  //formData[unqId] = selectedValue;
                  // DB Delete 요청
                  if(formData){
                    deleteFile(formData);
                    data = data.filter(function(item) {
                        return item[unqId] !== formData[unqId];
                    });
                    dataView.setItems(data, unqId1, unqId2, unqId3);
                    grid.getEditController().commitCurrentEdit();
                    grid.render();
                  }
                  renewOptions(false);
                });
              }
              
              // Apply a Mass Update change (apply changes to all items in the dataset)
              if (modalElm.querySelector("[data-action=mass-update]")) {
                modalElm.querySelector("[data-action=mass-update]").addEventListener('click', function () {
                  var validationResults = validateCompositeEditors();
                  var isFormValid = validationResults.valid;
          
                  if (isFormValid && lastCompositeEditor && lastCompositeEditor.formValues) {
                    // from the "lastCompositeEditor" object that we kept as reference, it contains all the changes inside the "formValues" property
                    // we can loop through these changes and apply them on the selected row indexes
                    for (const itemProp in lastCompositeEditor.formValues) {
                      if (lastCompositeEditor.formValues.hasOwnProperty(itemProp)) {
                        data.forEach(function (item) {
                          if (item.hasOwnProperty(itemProp) && lastCompositeEditor.formValues.hasOwnProperty(itemProp)) {
                            item[itemProp] = lastCompositeEditor.formValues[itemProp];
                          }
                        });
                      }
                    }
        
                    // change the entire dataset with our updated dataset
                    grid.setData(data, true);
                    grid.invalidate();
          
                    // once we're done doing the mass update, we can cancel the current editor since we don't want to add any new row
                    // that will also destroy/close the modal window
                    grid.getEditController().cancelCurrentEdit();
                    grid.setActiveCell(0, 0, false);
                  }
                });
              }
        
              const closeBtns = modalElm.querySelectorAll("[data-action=cancel],[data-action=close]");
              closeBtns.forEach(btn => {
                btn.addEventListener('click', function () {
                  // 원래 데이터로 복원
                  if (originalData) {
                    dataView.updateItem(originalData[unqId], originalData);
                  }
                  renewOptions(false);
                  grid.getEditController().cancelCurrentEdit();
                  grid.invalidate();
                })
              });
        
              var containers = modalColumns.map(function (c) {
                return modalElm.querySelector(`[data-editorid=${c.id}]`);
              });
          
              var compositeEditor = new Slick.CompositeEditor(
                modalColumns,
                containers,
                {
                  destroy: function () {
                    modalElm.remove();
                  },
                  modalType: modalType,
                  // validationMsgPrefix: '* '
                }
              );
              console.log("grid Active Column: ", grid.columns[grid.activeCell]);
              console.log(grid.isCellPotentiallyEditable(grid.activeRow, grid.activeCell));
              grid.editActiveCell(compositeEditor);
            }
        }
    </script>
</body>
</html>
